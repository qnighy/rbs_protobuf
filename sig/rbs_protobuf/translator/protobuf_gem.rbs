module RBSProtobuf
  module Translator
    class ProtobufGem < Base
      # Protobuf::Field::FieldArray[R, W]
      FIELD_ARRAY: Name::Class

      # Protobuf::Field::FieldHash[K, RV, WV]
      FIELD_HASH: Name::Class

      # Protobuf::Enum
      ENUM: Name::Class

      # Protobuf::Message
      MESSAGE: Name::Class

      attr_reader stderr: IO

      def initialize: (
        untyped input,
        upcase_enum: bool,
        nested_namespace: bool,
        extension: bool | :print | nil,
        ?stderr: IO
      ) -> void

      @upcase_enum: bool

      @nested_namespace: bool

      @extension: bool | :print | nil

      # Returns true if extension should be ignored.
      #
      def ignore_extension?: () -> bool

      # Returns true if documentation message about extension is requested.
      def print_extension_message?: () -> bool

      # Returns true if extension should be printed to stderr.
      #
      def print_extension?: () -> bool

      # Returns true if enum names should be `upcase`.
      #
      def upcase_enum?: () -> bool

      # Returns true if printing nested namespace is preferred.
      #
      def nested_namespace?: () -> bool

      # The entry point.
      # Generate RBS declarations from the `file` and returns the string representation of the declarations.
      #
      def rbs_content: (untyped file) -> String

      # Returns the class declaration for given message.
      #
      def message_to_decl: (untyped message, prefix: RBS::Namespace, message_path: untyped, source_code_info: untyped, path: Array[Integer]) -> RBS::AST::Declarations::Class

      # Returns the class declaration for given enum.
      #
      def enum_type_to_decl: (untyped enum_type, prefix: RBS::Namespace, source_code_info: untyped, path: Array[Integer]) -> RBS::AST::Declarations::Class

      # Returns the class declaration for given extension.
      #
      def extension_to_decl: (untyped extension, prefix: RBS::Namespace, source_code_info: untyped, path: Array[Integer]) -> RBS::AST::Declarations::Class

      # Returns `FieldArray` instance type.
      #
      def repeated_field_type: (RBS::Types::t `type`, ?RBS::Types::t wtype) -> RBS::Types::ClassInstance

      # Returns service class stub.
      #
      def service_to_decl: (untyped service, prefix: RBS::Namespace, source_code_info: untyped, path: Array[Integer]) -> RBS::AST::Declarations::Class

      # Returns a pair of types of a field.
      #
      # - The first one is the type of the attribute. (read and write)
      # - The second one is the array of type of additional possibilities for write.
      #
      def field_type: (untyped field, Hash[String, [RBS::Types::t, RBS::Types::t]] maps) -> [RBS::Types::t, Array[RBS::Types::t]]

      # Returns enum names with respect to `#upcase_enum?`.
      #
      def enum_name: (String name) -> Symbol

      # Add field to `members`. It adds
      #
      # - `attr_accessor` of the field `name` with `read_type`
      # - Overloads for attribute writer with `write_types`
      #
      def add_field: (Array[RBS::AST::Declarations::Class::member] members, name: Symbol, read_type: RBS::Types::t, write_types: Array[RBS::Types::t], comment: RBS::AST::Comment?) -> void

      def service_base_class: () -> RBS::AST::Declarations::Class::Super
    end
  end
end
